---
title: HTTP1.0 SPRDY HTTP2.0
date: 2017-03-26 16:25:01
categories: 编程
tags: [浏览器,优化]
---

### http2.0简介
#### http的基础

> 请求报文: 由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。
	
> 响应报文: 由协议版本、状态码、用于解释状态码的原因短句、可选的响应首部字段以及实体构成。
	
**HTTP1.1时代**

1. 持久化连接以便支持连接重用
2. 分块传输编码以支持流式响应
3. 请求管道以便支持并行请求处理
4. 字节服务以支持基于范围的资源请求
5. 改进的更好的缓存机制
		
http1.1主要增加了：
		
* keep-alive选项，建立连接后，在一定时间内不会断开，其他请求可以使用这条连接
* pipelining管道，通过这个管道，浏览器的多个请求可以同时发送到服务器，但是服务器的响应只能够一个接着一个的返回（但是大部分浏览器不支持或者默认关闭）
		
http1.1时代的优化：
		
* 连接和拼接
* 域名分区
* 资源内嵌
* SPDY时代
	
**SPDY基础功能**

* 多路复用
* 请求优先级
* header压缩
		 
**HTTP2.0时代** 

* 二进制分帧:在二进制分帧层上，http2.0会将所有传输的信息分隔为更小的消息和帧，并对它们采用二进制格式的编码，http1.x的首部信息会被封装到Headers帧，而request body则封装在Data帧里面。
* 压缩头部
* 多路复用：在一条连接上，可以同时发起无数个请求，并且响应可以同时返回。
* 请求优先级
* 服务器推送：是指在客户端请求之前发送数据的机制。另一优势：可以缓存
* 强制SSL
* 对优化的影响：
		
	① 由于“所有的http2.0的请求都在一个TCP连接上”，“资源合并减少请求”，比如css雪碧图、合并多个js，css文件等手段就没有必要了。
	
	② 由于“多路复用”，采用cdn1，cdn2打开多个TCP会话，突破浏览器对同一域名的连接数的限制就没有必要了。因为资源是并行交错发送，并且没有限制，不需要额外的多域名并行下载。
	
	③ 由于“服务器推送”，内嵌资源的优化手段也变得没有意义。而且使用服务器推送资源的方式更加高效，因为客户端还可以缓存起来，甚至可以由不同的页面共享（依旧遵循同源策略）。
			
			
#### HTTP2.0的前世

1. HTTP站在TCP之上

	* 三次握手有1.5个RTT的延迟，为了避免三次握手带来的延迟，应用层选择不同策略的http长连接方案。
	* TCP在建立连接初期，会有慢启动的特性，所以重用连接比建立新的连接性能要好。
	
2. HTTP的应用场景
3. 因为延迟，所以慢
	* 带宽
	* 延迟
	
	http1.0最大的缺点是***连接无法复用***和***head of line blocking***这两个问题。注意：客户端依据域名向服务器端建立连接，一般pc针对同一域名的server会同时建立6~8个连接，而m端控制在4~6个。
	>head of line blocking(线端阻塞)是指一个连接一次只提交一个请求的效率比较高，多了就会变慢. 多路复用可以很好的解决这个问题，因为它同时处理多个消息的请求和响应；甚至可以在传输过程中将一个消息跟另一个消息掺杂在一起。所以客户端只需要一个连接就能加载一个页面。
	
	* **连接无法复用**会导致每次请求都经历三次握手和慢启动。三次握手在高延迟场景下影响较明显，慢启动则对文件类请求影响较大。
	* **head of line blocking**会导致带宽无法被充分利用，以及后续请求被阻塞。
4. 解决连接无法复用
	http1.0里设置Connection:Keep-Alive,可以在一定时间内复用连接，具体复用时间可以由服务器端控制，一般是15s。
	http1.1之后，Connection的默认值为Keep-Alive,如果需要关闭需显式的设置Connection:close.但是对于移动端成效不大，app端的请求比较分散且时间跨度相对比较大。所以移动端app一般会从应用层寻求其他解决方案，长连接或者伪长连接方案。
	
	方案一：基于tcp的长连接
	方案二：http long-polling
	方案三：http stream
	方案四：web socket

5. SPDY的目标
	#### SPDY的基础
		* 多路复用
		* 请求优先级
		* header压缩
	#### SPDY高级功能
		* server推送
		* server暗示

			
	
		
	
	


